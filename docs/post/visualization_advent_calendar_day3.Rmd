---
title: "都道府県の市区町村を人口で2分割するやつ: 岡山県版"
author: "Shinya Uryu"
date: 2016-12-13T05:22:00
categories: ["visualization"]
featured: "161213-pref-33-populations-1.png"
featuredpath: "date"
description:
    市区町村ごとのの人口数によって、都道府県を2分割するというやつをRでやってみる。全国版はあとで
---

```{r setup, child = "../../_blog_post_declare.Rmd"}
```

少し前によく見かけたやつ。Rでやってみる。人口データはユタニーの**[`{estatapi}`](https://cran.r-project.org/web/packages/estatapi/index.html)**でe-Statから取得する。マッピングは手前味噌ながら、**[`{jpndistrict}`](https://cran.r-project.org/web/packages/jpndistrict/index.html)**パッケージを使うと楽。

必要なパッケージを読み込んで、データを取得、可視化までを行う。

```{r}
# データ取得・操作
library(estatapi)
library(jpndistrict)
library(magrittr)
library(spdplyr)
library(dplyr)
# library(tidyr)

# 可視化
library(ggplot2)
library(ggrepel)
```

## データの用意

まずはデータを用意する。人口データと地図データを用意する。

### 人口データ （平成27年国勢調査 人口等基本集計）

`estatapi::estat_getStatsList()`で「人口」をキーワードにして検索を行う。*appId*に与えるe-Statのトークンは各自で取得したものを使う。

```{r}
d.list <- estat_getStatsList(appId = Sys.getenv("ESTAT_TOKEN"), searchWord = "人口")
nrow(d.list)
```

「人口」で検索すると複数の項目がヒットするのだけど、そこから「平成27年国勢調査 人口等基本集計」のデータを選択する。

```{r}
d.list %>% filter(`@id` == "0003148500") %>% 
  select(`@id`, STAT_NAME, STATISTICS_NAME, TITLE, SURVEY_DATE)

# 全国のデータを取得
d.pops <- estat_getStatsData(
  appId = Sys.getenv("ESTAT_TOKEN"),
  statsDataId = "0003148500",
  cdCat01     = c("00710")
)
```

```{r}
d.pops %>% head()
```

データはこんな感じになっている。*地域（2015）*という列が行政区域の名称で、都道府県全体だったり市区町村だったりする。またそれにともなって*area_code*が割り振られている。人口の値は*value*に記録されている。使いやすいように少し処理を加える。

1. *area_code*の先頭2桁は都道府県コードなので、都道府県のデータを抽出できるように`mutate()`で都道府県コードの列を作成する。
2. 合併前の行政区域でのデータも含まれるため、市町村のデータに限定する（旧行政名は括弧で括られている）。この時、「区」のデータもあるのだが、区が含まれる「市」のデータがあるのでそれを利用するようにする。
3. 都道府県（1で作成した都道府県コードで`group_by()`）ごとに都道府県人口の過半数以上・未満で市町村を区分する。各市町村の人口数を都道府県の総人口で割り、人口数の少ない市町村から累積し、5割以上となる市町村をmajority、5割未満をminorityとして扱う。

```{r}
d.pops %<>% 
  # 都道府県コードの列を追加
  mutate(pref_code = substr(area_code, 1, 2)) %>% 
  # 市町村のデータを抽出（区は除外する）
  filter(`表章項目` == "人口",
         grepl("(市|町|村)$", `地域（2015）`)) %>% 
  # 必要な列だけを選択
  select(area_code, `地域（2015）`, value, pref_code) %>% 
  group_by(pref_code) %>% 
  do(aaa = arrange(., value) %>% 
       mutate(sum_value = value / sum(value),
         harf      = cumsum(sum_value)) %>% 
  mutate(type = if_else(harf <= 0.50, "minority", "majority"),
         type = ifelse(is.na(type), "minority", type)) %>% 
    select(-pref_code)) %>% 
  tidyr::unnest()
```

### 地図データ

国土数値情報の行政区域 平成27年4月1日時点のデータ http://nlftp.mlit.go.jp/ksj/gml/datalist/KsjTmplt-N03.html を利用してSpatialPolygonDataframeを作成する。ここでも区は市にまとめ、行政コードも市のものを採用するという処理をする。

```{r}
d33 <- spdf_jpn_pref(code = 33, district = TRUE) %>% 
  mutate(city_name = if_else(grepl("区$", city_name_full), city_name_, city_name),
                    city_code = ifelse(grepl("区$", city_name_full), 
                                         paste0(substr(city_code, 1, 3), "00"),
         as.character(city_code))) %>% 
  select(city_name, city_code)
```

### 行政名ラベルと位置データ（市区町村役場データ）

地図を作る際、市区町村ごとにラベルをふりたいので用意する。`jpndistrict::spdf_jpn_admins()`により、国土数値情報 市区町村役場データ http://nlftp.mlit.go.jp/ksj/gml/datalist/KsjTmplt-P34.html からデータをダウンロードする（すでにShapefileがあれば*path*引数でディレクトリを指定）

```{r}
d.admin33 <- spdf_jpn_admins(path = "/Users/uri/Dropbox/maps/shapefile/国土数値情報/P34/P34-14_33_GML/") %>% 
  mutate(name = gsub("(役所|役場|役場（移転中）)$", "", name)) %>% 
  filter(type == 1, !grepl("区$", name)) 
```

```{r, eval = FALSE, echo = TRUE}
d.admin33 <- spdf_jpn_admins(code = 33) %>% 
      dplyr::mutate(name = gsub("(役所|役場|役場（移転中）)$", "", name)) %>% 
  dplyr::filter(type == 1, !grepl("区$", name)) 
```

## プロット

あらかじめ、地図データを**`{ggplot2}`**ベースの地図として描画するために`ggplot2::fortify()`にかけ、人口データと結合させておく。あとは`geom_map`でデータをのせるだけ。

```{r}
d.map <- d33 %>% 
    ggplot2::fortify(region = "city_code") %>% 
    dplyr::left_join(d.pops, by = c("id" = "area_code"))
```

```{r}
p <- ggplot() +
  geom_map(data = d.map,
           map = d.map,
           aes(x = long, y = lat, group = group, map_id = id, fill = type),
           color = "#FFFFFF", size = 0.1) + 
  coord_map() +
  ggthemes::theme_map(base_size = 12, base_family = "YuGo") +
    guides(fill = FALSE)
```

ラベルは**`{ggrepel}`**の関数を使うとよしなに位置を調整してくれるので便利。

```{r}
# family は適当に変更
p <- p + geom_point(data = d.admin33@data, aes(x = longitude, y = latitude)) +
      ggrepel::geom_text_repel(data = d.admin33@data, 
                               aes(longitude, latitude, label = name, family = "IPAexGothic"))
```

```{r 161213-pref-33-populations, eval = FALSE, echo = FALSE}
p
```

岡山、倉敷論争に終止符が打たれる日はいつになるやら。

