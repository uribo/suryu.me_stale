---
title: "dplyrのベクトル要素変換用関数3種"
author: "Shinya Uryu"
date: 2016-11-23T06:30:00
categories: ["data_manipulation"]
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: show
    fig_caption: true
    df_print: kable
---

```{r setup, child = "../../_blog_post_declare.Rmd"}
```

```{r}
library(dplyr)
```

**`{dplyr}`**パッケージの現行バージョン (0.5.0) ではデータ操作の中で値を変更するための関数がいくつか用意されている。これらの関数の使い道と使い分けについてメモしておく。

簡単に整理するとこんな感じになる

| 関数 | 特徴 |
|------|------|
| `if_else()` | `ifelse()`の拡張。欠損値に対する挙動も指定できる |
| `case_when()` | ベクトルの各要素に対する挙動を指定。指定しない場合には欠損値として扱われるので注意 | 
| `recode()` | ベクトル内の特定の値だけを変更したいときに効果的。変換後の型に注意 |

## if_else関数

ドキュメントによるとこの関数は、R標準の制御関数の一つである`ifelse()`と比べてより厳密 strict なものであるらしい。真偽値の判定を実行するコード（xはyよりも大きい、xのクラスはzである、とか）と、真偽それぞれの状況の応答を引数に与えて実行する。またこの関数は、それだけでなくxの値が欠損値である場合についても特定の処理を実行するという特徴をもつ。欠損値に対する挙動は引数*missing*によって与える。

```{r}
x <- c(-3:3, NA)
if_else(x < 0, "negative", "positive", missing = "missing")
```

この関数はもちろん **`{dplyr}`** の`mutate()`内で利用できる。

```{r}
iris %>% head() %>% 
  mutate(Sepal.Size = if_else(Sepal.Length > 6.0, TRUE, FALSE))
```

`if_else()`では真偽値の判定を入れ子にして複数の分岐を作成することもできるが、データの値を修正する場合には、次の`case_when()`を用いるのが良い。

## case_when関数

変換候補が複数あるとき、`if_else()`よりも`case_when()`を使うのが効率的だ。`case_when()`では関数名の通り、条件分岐によるベクトル内の要素の変更を行う。書き方が特殊なので慣れが必要。引数内で条件式とそれに該当する値の変更値をチルダ記号（`~`）で繋いで指定する。

```{r}
x <- c(-3:3, NA)
case_when(
  x < 0 ~ "negative",
  x > 0 ~ "positive")
```

上記のように引数に与えた複数の条件に対して値が変更されるが、気をつけないといけないのが要素の各値に対する挙動である。個々の挙動を指定しないと、条件に当てはまらない、つまり真となる条件のない要素については欠損値に置換されてしまう。先の例では元の欠損値に加え、0もNAになっている。

で、これを`mutate()`の中で使うときの注意点。`mutate()`の中で関数を利用する場合、変数の参照は「`.$`」で行うということを思い出して次のようにする。

```{r}
df.animals <- tibble::frame_data(
  ~team, ~rank,
  "mouse", 1,
  "cow", 2,
  "tiger", 3,
  "rabbit", 4
)

df.animals %>% 
  mutate(
    rank = case_when(
      .$team == "mouse" ~ 3,
      .$team == "cow" ~ 2,
      .$team == "tiger" ~ 1,
      .$team == "rabbit" ~3
    )
  )
```

## recode

もう一つの関数、`recode()`。これはより細かいというか、個々の値に対して変換をしたいときに便利。これも引数で「対象の値 = 変換後の値」を記述する形式となる。変換するものがなければ省略して良いし、変換後の値だけを引数に与えても良い。その場合には要素の順に変換の対象としていく（この挙動がいまいち掴めない...）。

```{r}
x <- c(-3:3, NA)
recode(x, `3` = 6L, `-3` = -8L)

# 1, 2, 3... が対象となる
recode(x, 6L, -8L, 10L)
```

ベクトル内の要素は同じ型でなければいけないので、次のように整数と実数や数値ベクトルに文字列を混ぜようとすると怒られる。怒られるだけでなく、その他の値は欠損値となってしまう。

```{r}
# integerとnumericも区別されるので注意
recode(x, `3` = 6)
recode(x, `3` = "three")
```

すべての要素の挙動を指定する必要はないが、指定したもの以外の値について`.default`引数を用いて一括で指定できる。

```{r}
recode(x, `3` = "three", .default = "numeric")
```

同様に欠損値に対しても`.missing`引数での置換を行える。

```{r}
recode(x, `3` = "three", .default = "numeric", .missing = "missing")
```

私は`mutate()`と組み合わせてこういう使い方をしばしば行う。ここでは「`.$`」を使わない

```{r}
df.animals %>% 
  mutate(所属 = recode(team,
                     mouse  = "子",
                     cow    = "丑",
                     tiger  = "寅",
                     rabbit = "卯"))
```

ベクトルをカテゴリデータにする`recode_factor()`関数もあるがここでは割愛。
