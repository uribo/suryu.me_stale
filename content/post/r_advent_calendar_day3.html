---
title: "tidyverse脳になって階層構造のあるデータフレームを使いこなそう"
author: "Shinya Uryu"
date: 2016-12-06T08:45:00
categories: ["R", "data-manipulation", "tidyverse"]
featured: "161206-nested-data-frame.png"
featuredpath: "date"
description:
    tidyverseには欠かせない階層構造のあるデータフレームに関する解説です
---


<!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE -->

<p><span class="citation">@yutannihilationが書いた</span><strong>tidyverse</strong>の<a href="http://notchained.hatenablog.com/entry/tidyverse">記事</a>を眠気眼の状態で読んでしまって、眠気も吹き飛んで3時起きしました。訴訟。</p>
<p>さて、Rアドベントカレンダーの中で <span class="citation">@yutannihilation</span> や <span class="citation">@takeshi0406</span> が<strong>tidyverse</strong>についての記事を<a href="http://kiito.hatenablog.com/entry/2016/12/04/195835">続けて書いている</a>ことからも、<strong>tidyverse</strong>の普及具合がわかる昨今ですが、これらの記事の中であまり言及されていないことがあります。それはtidyverseに含まれるパッケージの一つである<strong><code>{dplyr}</code></strong>や<strong><code>{tidyr}</code></strong>が提供する<strong>nested data frame</strong>です。私個人はこれを<strong>階層構造のあるデータフレーム</strong>と呼んでいます。</p>
<p>一人Rアドベントカレンダーの3日目では、tidyverseに欠かせない思想である、この階層構造のあるデータフレームについて説明をしたいと思います。といっても春先に書いたこの記事の再放送的な感じでもあります。</p>
<p>参考) <a href="http://uribo.hatenablog.com/entry/2016/03/27/070000" class="uri">http://uribo.hatenablog.com/entry/2016/03/27/070000</a></p>
<p>Rにはデータフレームとリストというオブジェクトがあるのはみなさんご存知の通りです。データフレームは特に利用機会の多いオブジェクトで、csvやexcelから読み込んだオブジェクトはデータフレームに変換されます。統計処理やモデリングを実行する関数の多くがデータフレームの変数を対象としており、<strong><code>{dplyr}</code></strong>もデータフレームの操作を前提としています。その特徴は、列をなす変数と行を構成する表構造をとることでしょう。そのためデータフレームでは、1列目は3つの要素、2列目は4つの要素…といった<strong>サイズの異なるデータを扱えません</strong>。加えて列を構成するのはベクトルオブジェクトであるため、異なる種類のオブジェクトを一つの列の中で扱うことはできません。対して<strong>リストオブジェクトはデータフレームと比べると自由度の高いデータ格納形式</strong>です。リストには、ベクトルやデータフレーム、行列、さらにはリストまで、Rのオブジェクトを含めることができます。一方でその自由度の高さから、やや扱いに困ることがあります。データフレームと比べるとやはり操作性が悪いです。これらの<strong>データフレーム、リストのそれぞれの特徴を備えたのが階層構造のあるデータフレーム</strong>となります。その特徴を見ていきましょう。</p>
<p>階層構造のあるデータフレームでは、変数にリストやデータフレームを含めることが可能です。データフレームの中にデータフレーム、データフレームの中にリスト、このことがnestedの由縁です。具体的にどういうことかというのを<strong><code>{dplyr}</code></strong>と<strong><code>{tidyr}</code></strong>を使って示します。またデータの例として<strong><code>{gapminder}</code></strong>パッケージの世界各国の出生時平均余命に関するデータセットを利用します。まずはパッケージを読み込み、<strong>gapminder</strong>データセットの大きさを確認しておきましょう。</p>
<pre class="r"><code>library(tidyverse)
library(gapminder)

dim(gapminder)
## [1] 1704    6
head(gapminder)
## # A tibble: 6 × 6
##       country continent  year lifeExp      pop gdpPercap
##        &lt;fctr&gt;    &lt;fctr&gt; &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
## 1 Afghanistan      Asia  1952  28.801  8425333  779.4453
## 2 Afghanistan      Asia  1957  30.332  9240934  820.8530
## 3 Afghanistan      Asia  1962  31.997 10267083  853.1007
## 4 Afghanistan      Asia  1967  34.020 11537966  836.1971
## 5 Afghanistan      Asia  1972  36.088 13079460  739.9811
## 6 Afghanistan      Asia  1977  38.438 14880372  786.1134</code></pre>
<p>1704行、結構大きなデータサイズですね。一方でこのデータセットは国ごとの5年ごとの人口、出生時平均余命について記録したデータであるので、国 countryをキーとして入れ子にすることが可能です。</p>
<pre class="r"><code>gapminder %&gt;% count(continent, country)
## Source: local data frame [142 x 3]
## Groups: continent [?]
## 
##    continent                  country     n
##       &lt;fctr&gt;                   &lt;fctr&gt; &lt;int&gt;
## 1     Africa                  Algeria    12
## 2     Africa                   Angola    12
## 3     Africa                    Benin    12
## 4     Africa                 Botswana    12
## 5     Africa             Burkina Faso    12
## 6     Africa                  Burundi    12
## 7     Africa                 Cameroon    12
## 8     Africa Central African Republic    12
## 9     Africa                     Chad    12
## 10    Africa                  Comoros    12
## # ... with 132 more rows</code></pre>
<pre class="r"><code>nest_by_country &lt;- gapminder %&gt;% 
  group_by(country) %&gt;% 
  nest()</code></pre>
<p>階層構造のあるデータフレームを作る方法はいくつかあるのですが、上記のように<code>dplyr::group_by()</code>によるグループ化を行ったのち、<code>tidyr::nest()</code>を使うのが最も簡単です。あるいは、<code>gapminder %&gt;% tidyr::nest(-country)</code>で直接グループネストを作っても良いかもしれません。</p>
<p>さて、上記で作成した<strong>nest_by_country</strong>というオブジェクトを出力すると次の結果が得られます。</p>
<pre class="r"><code>nest_by_country
## # A tibble: 142 × 2
##        country               data
##         &lt;fctr&gt;             &lt;list&gt;
## 1  Afghanistan &lt;tibble [12 × 5]&gt;
## 2      Albania &lt;tibble [12 × 5]&gt;
## 3      Algeria &lt;tibble [12 × 5]&gt;
## 4       Angola &lt;tibble [12 × 5]&gt;
## 5    Argentina &lt;tibble [12 × 5]&gt;
## 6    Australia &lt;tibble [12 × 5]&gt;
## 7      Austria &lt;tibble [12 × 5]&gt;
## 8      Bahrain &lt;tibble [12 × 5]&gt;
## 9   Bangladesh &lt;tibble [12 × 5]&gt;
## 10     Belgium &lt;tibble [12 × 5]&gt;
## # ... with 132 more rows</code></pre>
<p>countryというのはグループ化に用いたキーですが、dataというのは何を示しているのでしょう。また、どうしてデータサイズが変わっているのでしょうか。これこそが階層構造のあるデータフレームの特徴となります。</p>
<p>nest_by_countryオブジェクト自体はデータフレームなので、変数の値を参照することができます。試しにdata変数の第一要素を参照してみましょう。</p>
<pre class="r"><code>nest_by_country$data[[1]]
## # A tibble: 12 × 5
##    continent  year lifeExp      pop gdpPercap
##       &lt;fctr&gt; &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
## 1       Asia  1952  28.801  8425333  779.4453
## 2       Asia  1957  30.332  9240934  820.8530
## 3       Asia  1962  31.997 10267083  853.1007
## 4       Asia  1967  34.020 11537966  836.1971
## 5       Asia  1972  36.088 13079460  739.9811
## 6       Asia  1977  38.438 14880372  786.1134
## 7       Asia  1982  39.854 12881816  978.0114
## 8       Asia  1987  40.822 13867957  852.3959
## 9       Asia  1992  41.674 16317921  649.3414
## 10      Asia  1997  41.763 22227415  635.3414
## 11      Asia  2002  42.129 25268405  726.7341
## 12      Asia  2007  43.828 31889923  974.5803</code></pre>
<p>元のgapminderデータが持っていたデータに近い値が出力されました。この値は実は、<code>nest_by_country$country[1]</code>のAfghanistanに含まれるデータを抽出したものとなっています。それは<strong><code>{dplyr}</code></strong>の次のコードを実行することで確認できます。</p>
<pre class="r"><code>nest_by_country$country[1]
## [1] Afghanistan
## 142 Levels: Afghanistan Albania Algeria Angola Argentina ... Zimbabwe

identical(nest_by_country$data[[1]],
          gapminder %&gt;% filter(country == &quot;Afghanistan&quot;) %&gt;% 
  select(-country))
## [1] TRUE</code></pre>
<p>つまり階層構造のあるデータフレームとは、データフレームに含まれる任意の変数をキーとし、そのキーに含まれる値を別のオブジェクトとし、キーと紐づいた変数に格納することを示しているのです。</p>
<p>多くのデータは、1つ以上のキーあるいはカテゴリ変数をもっています。そしてこれらのキーに応じて、キーに含まれる項目の数を集計したり、キーごとに処理を行ったり、統計モデリングを適用したりといったことが頻繁に行われます。これらの出力形式はさまざまですが、キーを基準としている以上、処理結果をキーと紐づけることが可能です。ですが、格納形式が厳密なデータフレームではそれができません。そのため、階層構造のあるデータフレームはリストのようにデータフレームの中にさらにオブジェクトを含めることを可能としています。これにより、元のデータ（キー）と処理結果を簡単に紐付け、再びデータフレームとして操作することができます。</p>
<p>また上記で、入れ子にされるオブジェクトを別のオブジェクトと書きましたが、これは先のようにデータフレームでなく、リストや統計解析のためのオブジェクトであってもネスト可能であることを示しています。今度は<code>dplyr::do()</code>を用いて線形回帰を行ってみましょう。<code>dplyr::do()</code>はグループに対し共通の処理を施すのに適しています。</p>
<pre class="r"><code>(do_by_country &lt;- gapminder %&gt;% 
  group_by(country) %&gt;% 
  do(data = lm(lifeExp ~ year, data = .)))
## Source: local data frame [142 x 2]
## Groups: &lt;by row&gt;
## 
## # A tibble: 142 × 2
##        country     data
## *       &lt;fctr&gt;   &lt;list&gt;
## 1  Afghanistan &lt;S3: lm&gt;
## 2      Albania &lt;S3: lm&gt;
## 3      Algeria &lt;S3: lm&gt;
## 4       Angola &lt;S3: lm&gt;
## 5    Argentina &lt;S3: lm&gt;
## 6    Australia &lt;S3: lm&gt;
## 7      Austria &lt;S3: lm&gt;
## 8      Bahrain &lt;S3: lm&gt;
## 9   Bangladesh &lt;S3: lm&gt;
## 10     Belgium &lt;S3: lm&gt;
## # ... with 132 more rows</code></pre>
<p>countryごとに<code>lm()</code>を適用した結果が格納されました。</p>
<pre class="r"><code>all.equal(
  do_by_country$data[[1]],
  gapminder %&gt;% filter(country == &quot;Afghanistan&quot;) %&gt;% 
  select(-country) %&gt;% 
  lm(lifeExp ~ year, data = .)
)
## [1] TRUE</code></pre>
<p>入れ子構造を解除するにはどうするのでしょうか。ご心配なく。<strong><code>{tidyr}</code></strong>には<code>nest()</code>と対をなす<code>unnest()</code>という関数が用意されています。しかしそれには入れ子となっているオブジェクトがデータフレームである必要があります。なので先の線形回帰の結果を<strong><code>{broom}</code></strong>パッケージの<code>tidy()</code>によりデータフレームとして扱えるようにしてから入れ子構造を解除します。</p>
<p><strong><code>{broom}</code></strong>パッケージは、Rの統計解析の関数の出力結果を扱いやすいデータフレームへと整形してくれる便利なパッケージです。例えば<code>lm()</code>の結果に対し<code>broom::tidy()</code>を実行すると切片や係数、p値などをデータフレーム形式で取得できます。</p>
<pre class="r"><code>do_by_country &lt;- gapminder %&gt;% 
  group_by(country) %&gt;% 
  do(data = lm(lifeExp ~ year, data = .) %&gt;% broom::tidy()) %&gt;% 
  tidyr::unnest()

do_by_country %&gt;% colnames()
## [1] &quot;country&quot;   &quot;term&quot;      &quot;estimate&quot;  &quot;std.error&quot; &quot;statistic&quot; &quot;p.value&quot;</code></pre>
<p>データフレームなので、<strong><code>{dplyr}</code></strong>の関数を使って特定の国の結果のみを取り出すことができます。</p>
<pre class="r"><code>do_by_country %&gt;% filter(country == &quot;Afghanistan&quot;)
## # A tibble: 2 × 6
##       country        term     estimate   std.error statistic
##        &lt;fctr&gt;       &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;
## 1 Afghanistan (Intercept) -507.5342716 40.48416195 -12.53661
## 2 Afghanistan        year    0.2753287  0.02045093  13.46289
## # ... with 1 more variables: p.value &lt;dbl&gt;</code></pre>
<p>しかし、全ての入れ子がデータフレームにできるわけではありません。そのような時には<strong><code>{purrr}</code></strong>による関数型プログラミングによるデータ操作が効果を発揮します。</p>
<pre class="r"><code>by_country &lt;- nest_by_country %&gt;% 
  dplyr::mutate(model = purrr::map(data, ~ lm(lifeExp ~ year, data = .)))

by_country %&gt;% unnest(model %&gt;% purrr::map(broom::tidy))
## # A tibble: 284 × 6
##        country        term      estimate    std.error  statistic
##         &lt;fctr&gt;       &lt;chr&gt;         &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;
## 1  Afghanistan (Intercept)  -507.5342716 40.484161954 -12.536613
## 2  Afghanistan        year     0.2753287  0.020450934  13.462890
## 3      Albania (Intercept)  -594.0725110 65.655359062  -9.048348
## 4      Albania        year     0.3346832  0.033166387  10.091036
## 5      Algeria (Intercept) -1067.8590396 43.802200843 -24.379118
## 6      Algeria        year     0.5692797  0.022127070  25.727749
## 7       Angola (Intercept)  -376.5047531 46.583370599  -8.082385
## 8       Angola        year     0.2093399  0.023532003   8.895964
## 9    Argentina (Intercept)  -389.6063445  9.677729641 -40.258031
## 10   Argentina        year     0.2317084  0.004888791  47.395847
## # ... with 274 more rows, and 1 more variables: p.value &lt;dbl&gt;
by_country %&gt;% unnest(model %&gt;% purrr::map(broom::augment))
## # A tibble: 1,704 × 10
##        country lifeExp  year  .fitted   .se.fit      .resid       .hat
##         &lt;fctr&gt;   &lt;dbl&gt; &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;
## 1  Afghanistan  28.801  1952 29.90729 0.6639995 -1.10629487 0.29487179
## 2  Afghanistan  30.332  1957 31.28394 0.5799442 -0.95193823 0.22494172
## 3  Afghanistan  31.997  1962 32.66058 0.5026799 -0.66358159 0.16899767
## 4  Afghanistan  34.020  1967 34.03722 0.4358337 -0.01722494 0.12703963
## 5  Afghanistan  36.088  1972 35.41387 0.3848726  0.67413170 0.09906760
## 6  Afghanistan  38.438  1977 36.79051 0.3566719  1.64748834 0.08508159
## 7  Afghanistan  39.854  1982 38.16716 0.3566719  1.68684499 0.08508159
## 8  Afghanistan  40.822  1987 39.54380 0.3848726  1.27820163 0.09906760
## 9  Afghanistan  41.674  1992 40.92044 0.4358337  0.75355828 0.12703963
## 10 Afghanistan  41.763  1997 42.29709 0.5026799 -0.53408508 0.16899767
## # ... with 1,694 more rows, and 3 more variables: .sigma &lt;dbl&gt;,
## #   .cooksd &lt;dbl&gt;, .std.resid &lt;dbl&gt;</code></pre>
<p>あるいは次のように<code>split()</code>でグループを分割し、各グループに対して<code>lm() %&gt;% broom::tidy()</code>を適用するのも一つの方法です。</p>
<pre class="r"><code>map_by_country &lt;- gapminder %&gt;% 
  split(.$country) %&gt;% 
  purrr::map(., ~ lm(lifeExp ~ year, data = .) %&gt;% broom::tidy())

map_by_country$Afghanistan
##          term     estimate   std.error statistic          p.value
## 1 (Intercept) -507.5342716 40.48416195 -12.53661 0.00000019340553
## 2        year    0.2753287  0.02045093  13.46289 0.00000009835213</code></pre>
<p>今回紹介したパッケージは、データセットを提供した<strong><code>{gapminder}</code></strong>をのぞいて、<strong><code>{tidyverse}</code></strong>に含まれているものです。すごい設計思想ですね。俺たちのtidyverseはこれからだ！</p>
<p>Enjoy!</p>



<!-- BLOGDOWN-HEAD






/BLOGDOWN-HEAD -->
