---
title: "tidyverse脳になって階層構造のあるデータフレームを使いこなそう"
author: "Shinya Uryu"
date: 2016-12-06T08:45:00
categories: ["R", "data-manipulation", "tidyverse"]
featured: "161206-nested-data-frame.png"
featuredpath: "date"
description:
    tidyverseには欠かせない階層構造のあるデータフレームに関する解説です
---

```{r setup, child = "../../_blog_post_declare.Rmd"}
```

@yutannihilationが書いた**tidyverse**の[記事](http://notchained.hatenablog.com/entry/tidyverse)を眠気眼の状態で読んでしまって、眠気も吹き飛んで3時起きしました。訴訟。

さて、Rアドベントカレンダーの中で @yutannihilation や @takeshi0406 が**tidyverse**についての記事を[続けて書いている](http://kiito.hatenablog.com/entry/2016/12/04/195835)ことからも、**tidyverse**の普及具合がわかる昨今ですが、これらの記事の中であまり言及されていないことがあります。それはtidyverseに含まれるパッケージの一つである**`{dplyr}`**や**`{tidyr}`**が提供する**nested data frame**です。私個人はこれを**階層構造のあるデータフレーム**と呼んでいます。

一人Rアドベントカレンダーの3日目では、tidyverseに欠かせない思想である、この階層構造のあるデータフレームについて説明をしたいと思います。といっても春先に書いたこの記事の再放送的な感じでもあります。

参考) http://uribo.hatenablog.com/entry/2016/03/27/070000

Rにはデータフレームとリストというオブジェクトがあるのはみなさんご存知の通りです。データフレームは特に利用機会の多いオブジェクトで、csvやexcelから読み込んだオブジェクトはデータフレームに変換されます。統計処理やモデリングを実行する関数の多くがデータフレームの変数を対象としており、**`{dplyr}`**もデータフレームの操作を前提としています。その特徴は、列をなす変数と行を構成する表構造をとることでしょう。そのためデータフレームでは、1列目は3つの要素、2列目は4つの要素...といった**サイズの異なるデータを扱えません**。加えて列を構成するのはベクトルオブジェクトであるため、異なる種類のオブジェクトを一つの列の中で扱うことはできません。対して**リストオブジェクトはデータフレームと比べると自由度の高いデータ格納形式**です。リストには、ベクトルやデータフレーム、行列、さらにはリストまで、Rのオブジェクトを含めることができます。一方でその自由度の高さから、やや扱いに困ることがあります。データフレームと比べるとやはり操作性が悪いです。これらの**データフレーム、リストのそれぞれの特徴を備えたのが階層構造のあるデータフレーム**となります。その特徴を見ていきましょう。

階層構造のあるデータフレームでは、変数にリストやデータフレームを含めることが可能です。データフレームの中にデータフレーム、データフレームの中にリスト、このことがnestedの由縁です。具体的にどういうことかというのを**`{dplyr}`**と**`{tidyr}`**を使って示します。またデータの例として**`{gapminder}`**パッケージの世界各国の出生時平均余命に関するデータセットを利用します。まずはパッケージを読み込み、**gapminder**データセットの大きさを確認しておきましょう。

```{r}
library(tidyverse)
library(gapminder)

dim(gapminder)
head(gapminder)
```

1704行、結構大きなデータサイズですね。一方でこのデータセットは国ごとの5年ごとの人口、出生時平均余命について記録したデータであるので、国 countryをキーとして入れ子にすることが可能です。

```{r}
gapminder %>% count(continent, country)
```

```{r}
nest_by_country <- gapminder %>% 
  group_by(country) %>% 
  nest()
```

階層構造のあるデータフレームを作る方法はいくつかあるのですが、上記のように`dplyr::group_by()`によるグループ化を行ったのち、`tidyr::nest()`を使うのが最も簡単です。あるいは、`gapminder %>% tidyr::nest(-country)`で直接グループネストを作っても良いかもしれません。

さて、上記で作成した**nest_by_country**というオブジェクトを出力すると次の結果が得られます。

```{r}
nest_by_country
```

countryというのはグループ化に用いたキーですが、dataというのは何を示しているのでしょう。また、どうしてデータサイズが変わっているのでしょうか。これこそが階層構造のあるデータフレームの特徴となります。

nest_by_countryオブジェクト自体はデータフレームなので、変数の値を参照することができます。試しにdata変数の第一要素を参照してみましょう。

```{r}
nest_by_country$data[[1]]
```

元のgapminderデータが持っていたデータに近い値が出力されました。この値は実は、`nest_by_country$country[1]`のAfghanistanに含まれるデータを抽出したものとなっています。それは**`{dplyr}`**の次のコードを実行することで確認できます。

```{r}
nest_by_country$country[1]

identical(nest_by_country$data[[1]],
          gapminder %>% filter(country == "Afghanistan") %>% 
  select(-country))
```

つまり階層構造のあるデータフレームとは、データフレームに含まれる任意の変数をキーとし、そのキーに含まれる値を別のオブジェクトとし、キーと紐づいた変数に格納することを示しているのです。

多くのデータは、1つ以上のキーあるいはカテゴリ変数をもっています。そしてこれらのキーに応じて、キーに含まれる項目の数を集計したり、キーごとに処理を行ったり、統計モデリングを適用したりといったことが頻繁に行われます。これらの出力形式はさまざまですが、キーを基準としている以上、処理結果をキーと紐づけることが可能です。ですが、格納形式が厳密なデータフレームではそれができません。そのため、階層構造のあるデータフレームはリストのようにデータフレームの中にさらにオブジェクトを含めることを可能としています。これにより、元のデータ（キー）と処理結果を簡単に紐付け、再びデータフレームとして操作することができます。

また上記で、入れ子にされるオブジェクトを別のオブジェクトと書きましたが、これは先のようにデータフレームでなく、リストや統計解析のためのオブジェクトであってもネスト可能であることを示しています。今度は`dplyr::do()`を用いて線形回帰を行ってみましょう。`dplyr::do()`はグループに対し共通の処理を施すのに適しています。

```{r}
(do_by_country <- gapminder %>% 
  group_by(country) %>% 
  do(data = lm(lifeExp ~ year, data = .)))
```

countryごとに`lm()`を適用した結果が格納されました。

```{r}
all.equal(
  do_by_country$data[[1]],
  gapminder %>% filter(country == "Afghanistan") %>% 
  select(-country) %>% 
  lm(lifeExp ~ year, data = .)
)
```

入れ子構造を解除するにはどうするのでしょうか。ご心配なく。**`{tidyr}`**には`nest()`と対をなす`unnest()`という関数が用意されています。しかしそれには入れ子となっているオブジェクトがデータフレームである必要があります。なので先の線形回帰の結果を**`{broom}`**パッケージの`tidy()`によりデータフレームとして扱えるようにしてから入れ子構造を解除します。

**`{broom}`**パッケージは、Rの統計解析の関数の出力結果を扱いやすいデータフレームへと整形してくれる便利なパッケージです。例えば`lm()`の結果に対し`broom::tidy()`を実行すると切片や係数、p値などをデータフレーム形式で取得できます。

```{r}
do_by_country <- gapminder %>% 
  group_by(country) %>% 
  do(data = lm(lifeExp ~ year, data = .) %>% broom::tidy()) %>% 
  tidyr::unnest()

do_by_country %>% colnames()
```

データフレームなので、**`{dplyr}`**の関数を使って特定の国の結果のみを取り出すことができます。

```{r}
do_by_country %>% filter(country == "Afghanistan")
```

しかし、全ての入れ子がデータフレームにできるわけではありません。そのような時には**`{purrr}`**による関数型プログラミングによるデータ操作が効果を発揮します。

```{r}
by_country <- nest_by_country %>% 
  dplyr::mutate(model = purrr::map(data, ~ lm(lifeExp ~ year, data = .)))

by_country %>% unnest(model %>% purrr::map(broom::tidy))
by_country %>% unnest(model %>% purrr::map(broom::augment))
```

あるいは次のように`split()`でグループを分割し、各グループに対して`lm() %>% broom::tidy()`を適用するのも一つの方法です。


```{r}
map_by_country <- gapminder %>% 
  split(.$country) %>% 
  purrr::map(., ~ lm(lifeExp ~ year, data = .) %>% broom::tidy())

map_by_country$Afghanistan
```

今回紹介したパッケージは、データセットを提供した**`{gapminder}`**をのぞいて、**`{tidyverse}`**に含まれているものです。すごい設計思想ですね。俺たちのtidyverseはこれからだ！

Enjoy!
